using System.Globalization;
using System.Text;
using System.Text.Json.Nodes;
using Microsoft.OpenApi;

namespace OpenApiCodeGenerator;

/// <summary>
/// Emits C# source code from OpenAPI schemas. Produces records, enums,
/// and type aliases in a modern C# style with nullable reference types.
/// </summary>
internal class CSharpCodeEmitter
{
    private readonly GeneratorOptions _options;
    private readonly TypeResolver _typeResolver;
    private readonly IDictionary<string, IOpenApiSchema> _allSchemas;
    private readonly StringBuilder _sb = new();
    private int _indent;

    /// <summary>
    /// Maps (schemaName, propertyName) → resolved enum type name for inline enums.
    /// Built during <see cref="Emit"/> so that <see cref="EmitProperty"/> can reference
    /// the correct (possibly deduplicated or differentiated) enum type name.
    /// </summary>
    private Dictionary<(string SchemaName, string PropertyName), string> _inlineEnumMap = new();

    public CSharpCodeEmitter(
        GeneratorOptions options,
        TypeResolver typeResolver,
        IDictionary<string, IOpenApiSchema> allSchemas)
    {
        _options = options;
        _typeResolver = typeResolver;
        _allSchemas = allSchemas;
    }

    /// <summary>
    /// Emit the full C# source file for all schemas.
    /// </summary>
    public string Emit()
    {
        _sb.Clear();
        _indent = 0;

        if (_options.GenerateFileHeader)
        {
            AppendLine("// <auto-generated>");
            AppendLine("// This file was auto-generated by OpenApiCodeGenerator.");
            AppendLine("// Do not make direct changes to the file.");
            AppendLine("// </auto-generated>");
            AppendLine();
        }

        AppendLine("#nullable enable");
        AppendLine();

        AppendLine("using System.Text.Json.Serialization;");
        AppendLine();

        AppendLine($"namespace {_options.Namespace};");
        AppendLine();

        // Two-pass type name resolution: detect collisions, assign clean names to
        // the most natural schema name, differentiate others meaningfully.
        Dictionary<string, string> typeNameMap = ResolveTypeNameCollisions(_allSchemas.Keys);

        // Pre-collect, deduplicate, and emit all inline enums before emitting records.
        // This ensures matching inline enums across schemas are emitted once, and
        // conflicting ones get differentiated names.
        _inlineEnumMap = ResolveInlineEnums(typeNameMap);
        EmitResolvedInlineEnums(_inlineEnumMap);

        foreach ((string? name, IOpenApiSchema? schema) in _allSchemas)
        {
            EmitSchemaWithTypeName(name, schema, typeNameMap[name]);
        }

        return _sb.ToString().TrimEnd() + Environment.NewLine;
    }

    #region Inline Enum Resolution

    /// <summary>
    /// Collects all inline enum properties across all schemas, deduplicates
    /// matching enums (same type name and same values), and differentiates
    /// conflicting ones (same type name, different values) by prefixing
    /// with the enclosing schema's type name.
    /// Returns a map of (schemaName, propertyName) → resolved enum type name.
    /// </summary>
    private Dictionary<(string SchemaName, string PropertyName), string> ResolveInlineEnums(Dictionary<string, string> typeNameMap)
    {
        var result = new Dictionary<(string, string), string>();

        // Collect all inline enums: (schemaName, propertyName, enumTypeName, enumValues, schema)
        var inlineEnums = new List<(string SchemaName, string PropertyName, string EnumTypeName, List<string> Values, IOpenApiSchema Schema)>();

        foreach ((string? schemaName, IOpenApiSchema? schema) in _allSchemas)
        {
            Dictionary<string, IOpenApiSchema> properties = CollectProperties(schema);
            foreach ((string? propName, IOpenApiSchema? propSchema) in properties)
            {
                if (TypeResolver.IsEnum(propSchema) && !_allSchemas.Values.Contains(propSchema))
                {
                    string enumTypeName = NameHelper.ToPropertyName(propName, typeNameMap.GetValueOrDefault(schemaName));
                    List<string> values = ExtractEnumValues(propSchema);
                    inlineEnums.Add((schemaName, propName, enumTypeName, values, propSchema));
                }
            }
        }

        // Group by would-be enum type name
        var groups = inlineEnums
            .GroupBy(e => e.EnumTypeName)
            .ToList();

        var usedNames = new HashSet<string>(StringComparer.Ordinal);
        // Reserve top-level schema type names to avoid conflicts
        foreach (string tn in typeNameMap.Values)
        {
            usedNames.Add(tn);
        }

        foreach (IGrouping<string, (string SchemaName, string PropertyName, string EnumTypeName, List<string> Values, IOpenApiSchema Schema)> group in groups)
        {
            string baseName = group.Key;

            // Sub-group by enum values (identical value lists share a name)
            var valueGroups = group
                .GroupBy(e => string.Join("|", e.Values))
                .ToList();

            if (valueGroups.Count == 1)
            {
                // All inline enums with this name have identical values → single enum
                string resolvedName = baseName;
                if (usedNames.Contains(resolvedName))
                {
                    // Conflict with a top-level type; differentiate
                    resolvedName = FindUniqueName(baseName, usedNames);
                }
                usedNames.Add(resolvedName);
                foreach ((string SchemaName, string PropertyName, string EnumTypeName, List<string> Values, IOpenApiSchema Schema) in valueGroups[0])
                {
                    result[(SchemaName, PropertyName)] = resolvedName;
                }
            }
            else
            {
                // Conflicting values → differentiate each value group
                foreach (IGrouping<string, (string SchemaName, string PropertyName, string EnumTypeName, List<string> Values, IOpenApiSchema Schema)> valueGroup in valueGroups)
                {
                    // Use the first entry's enclosing schema name as prefix
                    (string SchemaName, string PropertyName, string EnumTypeName, List<string> Values, IOpenApiSchema Schema) = valueGroup.First();
                    string schemaTypeName = typeNameMap.GetValueOrDefault(SchemaName, SchemaName);
                    string candidateName = schemaTypeName + baseName;
                    if (usedNames.Contains(candidateName))
                    {
                        candidateName = FindUniqueName(candidateName, usedNames);
                    }
                    usedNames.Add(candidateName);
                    foreach ((string SchemaName, string PropertyName, string EnumTypeName, List<string> Values, IOpenApiSchema Schema) entry in valueGroup)
                    {
                        result[(entry.SchemaName, entry.PropertyName)] = candidateName;
                    }
                }
            }
        }

        return result;
    }

    /// <summary>
    /// Emits the deduplicated inline enums. Each unique enum type name is emitted
    /// exactly once using the first matching schema as the source.
    /// </summary>
    private void EmitResolvedInlineEnums(
        Dictionary<(string SchemaName, string PropertyName), string> inlineEnumMap)
    {
        // Collect unique (resolvedName → schema) pairs, emit once each
        var emitted = new HashSet<string>(StringComparer.Ordinal);

        foreach (((string schemaName, string propertyName), string resolvedName) in inlineEnumMap)
        {
            if (!emitted.Add(resolvedName))
            {
                continue; // already emitted
            }

            // Find the inline enum schema
            Dictionary<string, IOpenApiSchema> properties = CollectProperties(_allSchemas[schemaName]);
            if (properties.TryGetValue(propertyName, out IOpenApiSchema? enumSchema))
            {
                EmitEnum(propertyName, enumSchema, resolvedName);
            }
        }
    }

    /// <summary>
    /// Extracts the raw enum values from a schema as a normalized list of strings.
    /// </summary>
    private static List<string> ExtractEnumValues(IOpenApiSchema schema)
    {
        return schema.Enum!
            .Select(e =>
            {
                if (e is JsonValue jv)
                {
                    if (jv.TryGetValue(out string? s))
                    {
                        return s;
                    }

                    if (jv.TryGetValue(out int i))
                    {
                        return i.ToString(CultureInfo.InvariantCulture);
                    }

                    if (jv.TryGetValue(out long l))
                    {
                        return l.ToString(CultureInfo.InvariantCulture);
                    }

                    if (jv.TryGetValue(out double d))
                    {
                        return d.ToString(CultureInfo.InvariantCulture);
                    }
                }
                return e?.ToString() ?? "Unknown";
            })
            .ToList();
    }

    private static string FindUniqueName(string baseName, HashSet<string> usedNames)
    {
        int suffix = 2;
        string candidate = baseName + suffix;
        while (usedNames.Contains(candidate))
        {
            suffix++;
            candidate = baseName + suffix;
        }
        return candidate;
    }

    #endregion

    private void EmitSchemaWithTypeName(string schemaName, IOpenApiSchema schema, string typeName)
    {
        if (TypeResolver.IsEnum(schema))
        {
            EmitEnum(schemaName, schema, typeName);
        }
        else if (ShouldEmitAsRecord(schema))
        {
            EmitRecord(schemaName, schema, typeName);
        }
        else if (TypeResolver.IsTypeAlias(schema))
        {
            EmitTypeAlias(schemaName, schema, typeName);
        }
        else if (schema.OneOf is { Count: > 0 } || schema.AnyOf is { Count: > 0 })
        {
            EmitUnionType(schemaName, schema, typeName);
        }
        else
        {
            // Fallback: emit as a record with no properties
            EmitDocComment(schema.Description);
            AppendLine($"public record {typeName};");
            AppendLine();
        }
    }

    private static bool ShouldEmitAsRecord(IOpenApiSchema schema)
    {
        // Direct properties
        if (schema.Properties is { Count: > 0 })
        {
            return true;
        }

        // allOf with at least one schema that has properties
        if (schema.AllOf is { Count: > 0 })
        {
            foreach (IOpenApiSchema sub in schema.AllOf)
            {
                if (sub.Properties is { Count: > 0 })
                {
                    return true;
                }

                if (sub is OpenApiSchemaReference)
                {
                    return true; // inheritance
                }
            }
        }

        // Object type with additionalProperties
        if (TypeResolver.HasTypeFlag(schema, JsonSchemaType.Object) && schema.AdditionalProperties != null)
        {
            return false; // handled as a dictionary alias
        }

        if (TypeResolver.HasTypeFlag(schema, JsonSchemaType.Object))
        {
            return true;
        }

        return false;
    }

    #region Enum Emission

    private void EmitEnum(string schemaName, IOpenApiSchema schema, string? typeNameOverride = null)
    {
        string typeName = typeNameOverride ?? NameHelper.ToTypeName(schemaName);

        EmitDocComment(schema.Description);

        if (TypeResolver.HasTypeFlag(schema, JsonSchemaType.String))
        {
            AppendLine("[JsonConverter(typeof(JsonStringEnumConverter))]");
        }

        AppendLine($"public enum {typeName}");
        AppendLine("{");
        _indent++;

        var enumValues = schema.Enum!
            .Select(e =>
            {
                if (e is JsonValue jv)
                {
                    if (jv.TryGetValue(out string? s))
                    {
                        return s;
                    }

                    if (jv.TryGetValue(out int i))
                    {
                        return i.ToString(CultureInfo.InvariantCulture);
                    }

                    if (jv.TryGetValue(out long l))
                    {
                        return l.ToString(CultureInfo.InvariantCulture);
                    }

                    if (jv.TryGetValue(out double d))
                    {
                        return d.ToString(CultureInfo.InvariantCulture);
                    }
                }
                return e?.ToString() ?? "Unknown";
            })
            .ToList();

        for (int i = 0; i < enumValues.Count; i++)
        {
            string rawValue = enumValues[i];
            string memberName = NameHelper.ToEnumMemberName(rawValue);
            bool isLast = i == enumValues.Count - 1;

            if (TypeResolver.HasTypeFlag(schema, JsonSchemaType.String))
            {
                AppendLine($"[JsonStringEnumMemberName(\"{rawValue.Replace("\"", "\\\"", StringComparison.Ordinal)}\")]");
            }

            if ((TypeResolver.HasTypeFlag(schema, JsonSchemaType.Integer) || TypeResolver.HasTypeFlag(schema, JsonSchemaType.Number))
                && double.TryParse(rawValue, NumberStyles.Any, CultureInfo.InvariantCulture, out _))
            {
                Append($"{memberName} = {rawValue}");
            }
            else
            {
                Append($"{memberName}");
            }

            AppendLineRaw(isLast ? "" : ",");
        }

        _indent--;
        AppendLine("}");
        AppendLine();
    }

    #endregion

    #region Record Emission

    private void EmitRecord(string schemaName, IOpenApiSchema schema, string? typeNameOverride = null)
    {
        string typeName = typeNameOverride ?? NameHelper.ToTypeName(schemaName);

        // Collect all properties (including from allOf)
        Dictionary<string, IOpenApiSchema> properties = CollectProperties(schema);
        HashSet<string> requiredProps = CollectRequired(schema);

        // Determine base type from allOf $ref
        string? baseType = null;
        HashSet<string>? basePropertyNames = null;
        if (schema.AllOf is { Count: > 0 })
        {
            OpenApiSchemaReference? refSchema = schema.AllOf.OfType<OpenApiSchemaReference>().FirstOrDefault();
            if (refSchema?.Reference?.Id != null)
            {
                baseType = NameHelper.ToTypeName(refSchema.Reference.Id);
                basePropertyNames = CollectBasePropertyNames(refSchema);
            }
        }

        EmitDocComment(schema.Description);

        string declaration = baseType != null
            ? $"public record {typeName} : {baseType}"
            : $"public record {typeName}";

        AppendLine(declaration);
        AppendLine("{");
        _indent++;

        // Filter out properties already defined in a base type
        var filteredProps = properties
            .Where(p => basePropertyNames == null || !basePropertyNames.Contains(p.Key))
            .ToList();

        // Two-pass property name resolution: detect collisions, assign clean names to
        // the most natural property name, differentiate others meaningfully.
        Dictionary<string, string> propertyNameMap = ResolvePropertyNameCollisions(filteredProps.Select(p => p.Key), typeName);

        foreach ((string? propName, IOpenApiSchema? propSchema) in filteredProps)
        {
            EmitProperty(propName, propSchema, requiredProps.Contains(propName), schemaName, typeName, propertyNameMap[propName]);
        }

        // If object has additionalProperties alongside regular properties
        if (schema.AdditionalProperties is { } additionalProps &&
            schema.Properties is { Count: > 0 })
        {
            string valueType = _typeResolver.Resolve(additionalProps);
            string dictType = _options.UseImmutableDictionaries ? "IReadOnlyDictionary" : "Dictionary";
            AppendLine();

            AppendLine("[JsonExtensionData]");

            AppendLine($"public {dictType}<string, {valueType}>? AdditionalProperties {{ get; init; }}");
        }

        _indent--;
        AppendLine("}");
        AppendLine();
    }

    private void EmitProperty(string propertyName, IOpenApiSchema propertySchema, bool isRequired, string? schemaName = null, string? enclosingTypeName = null, string? csharpNameOverride = null)
    {
        EmitDocComment(propertySchema.Description);

        string csharpPropertyName = csharpNameOverride ?? NameHelper.ToPropertyName(propertyName, enclosingTypeName);
        string? jsonName = NameHelper.GetJsonPropertyName(propertyName, csharpPropertyName);

        // Resolve the type
        string typeName;
        if (propertySchema is OpenApiSchemaReference propRef && propRef.Reference.Id is not null)
        {
            string refTypeName = NameHelper.ToTypeName(propRef.Reference.Id);
            typeName = isRequired ? refTypeName : refTypeName + "?";
        }
        else if (TypeResolver.IsEnum(propertySchema) && !_allSchemas.Values.Contains(propertySchema))
        {
            // Inline enum — look up the resolved enum type name from the
            // pre-computed inline enum map (handles dedup & conflict resolution).
            string enumTypeName = csharpPropertyName; // fallback
            if (schemaName != null)
            {
                (string schemaName, string propertyName) key = (schemaName, propertyName);
                if (_inlineEnumMap.TryGetValue(key, out string? resolved))
                {
                    enumTypeName = resolved;
                }
            }

            typeName = isRequired ? enumTypeName : enumTypeName + "?";
        }
        else
        {
            typeName = _typeResolver.ResolveWithNullability(propertySchema, isRequired);
        }

        // Add JSON attribute
        if (jsonName != null)
        {
            AppendLine($"[JsonPropertyName(\"{jsonName.Replace("\"", "\\\"", StringComparison.Ordinal)}\")]");
        }

        // Resolve the C# default value literal (if any)
        string? defaultLiteral = ToCSharpDefaultLiteral(propertySchema, typeName);
        string defaultSuffix = defaultLiteral != null ? $" = {defaultLiteral};" : "";

        // Add required keyword for required properties
        if (isRequired)
        {
            AppendLine($"public required {typeName} {csharpPropertyName} {{ get; init; }}{defaultSuffix}");
        }
        else
        {
            AppendLine($"public {typeName} {csharpPropertyName} {{ get; init; }}{defaultSuffix}");
        }

        AppendLine();
    }

    /// <summary>
    /// Converts an OpenAPI schema's default value to a C# literal string.
    /// Returns null when no default is specified or the default cannot be represented.
    /// </summary>
    private string? ToCSharpDefaultLiteral(IOpenApiSchema schema, string resolvedTypeName)
    {
        if (schema.Default is not JsonNode defaultNode)
        {
            return null;
        }

        if (!_options.AddDefaultValuesToProperties)
        {
            return "null!"; // Return null to avoid warnings in code.
        }

        // Strip trailing '?' from nullable types for matching purposes
        string baseTypeName = resolvedTypeName.TrimEnd('?');

        if (defaultNode is JsonValue jv)
        {
            // Boolean
            if (jv.TryGetValue(out bool boolVal))
            {
                return boolVal ? "true" : "false";
            }

            // String-based types
            if (jv.TryGetValue(out string? strVal))
            {
                // Inline or top-level enum: convert to EnumType.MemberName
                if (TypeResolver.IsEnum(schema) || IsEnumTypeName(baseTypeName))
                {
                    string memberName = NameHelper.ToEnumMemberName(strVal);
                    return $"{_options.Namespace}.{baseTypeName}.{memberName}";
                }

                if (string.IsNullOrEmpty(schema.Format))
                {
                    return $"\"{strVal.Replace("\"", "\\\"", StringComparison.Ordinal)}\"";
                }

                if (schema.Format == "date-time" && DateTime.TryParse(strVal, null, DateTimeStyles.AdjustToUniversal, out DateTime dt))
                {
                    return $"DateTime.Parse(\"{dt.ToString("o", CultureInfo.InvariantCulture)}\", null, DateTimeStyles.AdjustToUniversal)";
                }

                if (schema.Format == "date" && DateTime.TryParse(strVal, null, DateTimeStyles.None, out DateTime d))
                {
                    return $"DateTime.Parse(\"{d:yyyy-MM-dd}\")";
                }

                if (schema.Format == "time" && TimeSpan.TryParse(strVal, out TimeSpan ts))
                {
                    return $"TimeSpan.Parse(\"{ts:c}\")";
                }

                if (schema.Format == "uuid" && Guid.TryParse(strVal, out Guid guid))
                {
                    return $"Guid.Parse(\"{guid}\")";
                }

                if (schema.Format == "uri" && Uri.TryCreate(strVal, UriKind.Absolute, out Uri? uri))
                {
                    return $"new Uri(\"{uri}\")";
                }

                return "null!";
            }

            // Integer types
            if (jv.TryGetValue(out int intVal))
            {
                return intVal.ToString(CultureInfo.InvariantCulture);
            }

            if (jv.TryGetValue(out long longVal))
            {
                return baseTypeName switch
                {
                    "long" => longVal.ToString(CultureInfo.InvariantCulture) + "L",
                    _ => longVal.ToString(CultureInfo.InvariantCulture)
                };
            }

            // Floating-point types
            if (jv.TryGetValue(out double dblVal))
            {
                return baseTypeName switch
                {
                    "float" => dblVal.ToString(CultureInfo.InvariantCulture) + "f",
                    "decimal" => dblVal.ToString(CultureInfo.InvariantCulture) + "m",
                    _ => dblVal.ToString(CultureInfo.InvariantCulture) + "d"
                };
            }
        }

        // Arrays: emit as empty collection
        if (defaultNode is JsonArray)
        {
            return "[]";
        }

        return null;
    }

    /// <summary>
    /// Checks whether a resolved type name corresponds to an enum (either a top-level
    /// schema enum or an inline enum registered in the inline enum map).
    /// </summary>
    private bool IsEnumTypeName(string typeName)
    {
        // Check top-level schemas for a matching enum
        foreach ((string? name, IOpenApiSchema? schema) in _allSchemas)
        {
            if (NameHelper.ToTypeName(name) == typeName && TypeResolver.IsEnum(schema))
            {
                return true;
            }
        }

        // Check inline enum map
        return _inlineEnumMap.ContainsValue(typeName);
    }

    #endregion

    #region Type Alias Emission

    private void EmitTypeAlias(string schemaName, IOpenApiSchema schema, string? typeNameOverride = null)
    {
        string typeName = typeNameOverride ?? NameHelper.ToTypeName(schemaName);
        string resolvedType = _typeResolver.ResolveUnderlyingType(schema);

        EmitDocComment(schema.Description);

        // C# doesn't have direct type aliases at the top level.
        // We emit a global using alias or a wrapper record.
        // For simplicity and usability, emit a readonly record struct wrapping the value.
        AppendLine($"/// <summary>");
        AppendLine($"/// Type alias for {resolvedType}.");
        AppendLine($"/// </summary>");
        AppendLine($"public record struct {typeName}({resolvedType} Value);");
        AppendLine();
    }

    #endregion

    #region Union Type Emission

    private void EmitUnionType(string schemaName, IOpenApiSchema schema, string? typeNameOverride = null)
    {
        string typeName = typeNameOverride ?? NameHelper.ToTypeName(schemaName);
        IList<IOpenApiSchema> variants = schema.OneOf ?? schema.AnyOf ?? [];

        EmitDocComment(schema.Description);

        if (schema.Discriminator is { PropertyName: not null } disc)
        {
            // Emit discriminated union using JsonDerivedType
            EmitDiscriminatedUnion(typeName, variants, disc);
        }
        else
        {
            // Emit as a marker interface / abstract record
            EmitSimpleUnion(typeName, variants);
        }
    }

    private void EmitDiscriminatedUnion(
        string typeName,
        IList<IOpenApiSchema> variants,
        OpenApiDiscriminator discriminator)
    {
        // Build mapping: discriminator value → type name
        var mapping = new Dictionary<string, string>();
        if (discriminator.Mapping is { Count: > 0 })
        {
            foreach ((string? key, OpenApiSchemaReference? schemaRef) in discriminator.Mapping)
            {
                mapping[key] = NameHelper.ToTypeName(schemaRef.Reference.Id);
            }
        }
        else
        {
            // Infer mapping from $ref names
            foreach (IOpenApiSchema variant in variants)
            {
                if (variant is OpenApiSchemaReference variantRef)
                {
                    string? name = variantRef.Reference.Id;

                    if (name is null)
                    {
                        continue;
                    }

                    mapping[name] = NameHelper.ToTypeName(name);
                }
            }
        }

        foreach ((string? discriminatorValue, string? derivedType) in mapping)
        {
            AppendLine($"[JsonDerivedType(typeof({derivedType}), \"{discriminatorValue}\")]");
        }

        AppendLine($"[JsonPolymorphic(TypeDiscriminatorPropertyName = \"{discriminator.PropertyName}\")]");

        AppendLine($"public abstract record {typeName};");
        AppendLine();
    }

    private void EmitSimpleUnion(string typeName, IList<IOpenApiSchema> variants)
    {
        // Collect the variant type names for documentation
        var variantNames = variants
            .OfType<OpenApiSchemaReference>()
            .Select(v => NameHelper.ToTypeName(v.Reference.Id))
            .ToList();

        if (variantNames.Count > 0)
        {
            AppendLine($"/// <remarks>");
            AppendLine($"/// Union of: {string.Join(" | ", variantNames)}");
            AppendLine($"/// </remarks>");
        }

        // If all variants are $refs, emit as an abstract record with JsonDerivedType attributes
        if (variants.All(v => v is OpenApiSchemaReference))
        {
            foreach (OpenApiSchemaReference variant in variants.OfType<OpenApiSchemaReference>())
            {
                string derivedName = NameHelper.ToTypeName(variant.Reference.Id);
                AppendLine($"[JsonDerivedType(typeof({derivedName}), \"{variant.Reference.Id}\")]");
            }
        }

        AppendLine($"public abstract record {typeName};");
        AppendLine();
    }

    #endregion

    #region Name Collision Resolution

    /// <summary>
    /// Resolves type name collisions across all schemas using a two-pass approach.
    /// In each collision group, the most "natural" schema name keeps the clean PascalCase
    /// type name, and others get meaningfully differentiated names.
    /// </summary>
    private static Dictionary<string, string> ResolveTypeNameCollisions(IEnumerable<string> schemaNames)
    {
        var result = new Dictionary<string, string>();
        var usedNames = new HashSet<string>(StringComparer.Ordinal);

        // Group schema names by their PascalCase type name
        var groups = schemaNames
            .Select(name => (Original: name, PascalName: NameHelper.ToTypeName(name)))
            .GroupBy(x => x.PascalName)
            .ToList();

        foreach (IGrouping<string, (string Original, string PascalName)>? group in groups)
        {
            string pascalName = group.Key;
            var members = group.ToList();

            if (members.Count == 1)
            {
                result[members[0].Original] = pascalName;
                usedNames.Add(pascalName);
                continue;
            }

            // Sort by naturalness: most natural name keeps the clean PascalCase
            var sorted = members.OrderBy(m => NameHelper.NaturalnessScore(m.Original, pascalName)).ToList();

            // Winner gets the clean name
            result[sorted[0].Original] = pascalName;
            usedNames.Add(pascalName);

            // Others get differentiated names
            for (int i = 1; i < sorted.Count; i++)
            {
                string differentiated = NameHelper.ToDifferentiatedName(sorted[i].Original, pascalName, usedNames);
                result[sorted[i].Original] = differentiated;
                usedNames.Add(differentiated);
            }
        }

        return result;
    }

    /// <summary>
    /// Resolves property name collisions within a record using a two-pass approach.
    /// In each collision group, the most "natural" property name keeps the clean PascalCase
    /// name, and others get meaningfully differentiated names.
    /// </summary>
    private static Dictionary<string, string> ResolvePropertyNameCollisions(IEnumerable<string> propertyNames, string typeName)
    {
        var result = new Dictionary<string, string>();
        var usedNames = new HashSet<string>(StringComparer.Ordinal);

        // Group property names by their PascalCase form
        var groups = propertyNames
            .Select(name => (Original: name, PascalName: NameHelper.ToPropertyName(name, typeName)))
            .GroupBy(x => x.PascalName)
            .ToList();

        foreach (IGrouping<string, (string Original, string PascalName)>? group in groups)
        {
            string pascalName = group.Key;
            var members = group.ToList();

            if (members.Count == 1)
            {
                result[members[0].Original] = pascalName;
                usedNames.Add(pascalName);
                continue;
            }

            // Sort by naturalness: most natural name keeps the clean PascalCase
            var sorted = members.OrderBy(m => NameHelper.NaturalnessScore(m.Original, pascalName)).ToList();

            // Winner gets the clean name
            result[sorted[0].Original] = pascalName;
            usedNames.Add(pascalName);

            // Others get differentiated names
            for (int i = 1; i < sorted.Count; i++)
            {
                string differentiated = NameHelper.ToDifferentiatedName(sorted[i].Original, pascalName, usedNames);
                result[sorted[i].Original] = differentiated;
                usedNames.Add(differentiated);
            }
        }

        return result;
    }

    #endregion

    #region Helpers

    private static Dictionary<string, IOpenApiSchema> CollectProperties(IOpenApiSchema schema)
    {
        var result = new Dictionary<string, IOpenApiSchema>();

        // Properties from allOf subschemas (excluding $ref ones which become base types)
        if (schema.AllOf is { Count: > 0 })
        {
            foreach (IOpenApiSchema sub in schema.AllOf)
            {
                if (sub is OpenApiSchemaReference)
                {
                    continue; // Skip $ref entries, they become base types
                }

                if (sub.Properties != null)
                {
                    foreach ((string? name, IOpenApiSchema? prop) in sub.Properties)
                    {
                        result.TryAdd(name, prop);
                    }
                }
            }
        }

        // Direct properties
        if (schema.Properties != null)
        {
            foreach ((string? name, IOpenApiSchema? prop) in schema.Properties)
            {
                result.TryAdd(name, prop);
            }
        }

        return result;
    }

    /// <summary>
    /// Recursively collects all property names defined in a base type and its ancestors.
    /// Used to avoid re-declaring properties that would hide required base members (CS9031).
    /// </summary>
    private HashSet<string> CollectBasePropertyNames(IOpenApiSchema baseSchema)
    {
        var names = new HashSet<string>(StringComparer.Ordinal);

        // Resolve references through our schema dictionary
        IOpenApiSchema resolved = baseSchema;
        if (baseSchema is OpenApiSchemaReference schemaRef
            && schemaRef.Reference?.Id is not null
            && _allSchemas.TryGetValue(schemaRef.Reference.Id, out IOpenApiSchema? lookedUp))
        {
            resolved = lookedUp;
        }

        // Collect direct properties
        if (resolved.Properties != null)
        {
            foreach (string name in resolved.Properties.Keys)
            {
                names.Add(name);
            }
        }

        // Recurse into allOf to collect ancestor properties
        if (resolved.AllOf is { Count: > 0 })
        {
            foreach (IOpenApiSchema sub in resolved.AllOf)
            {
                if (sub.Properties != null)
                {
                    foreach (string name in sub.Properties.Keys)
                    {
                        names.Add(name);
                    }
                }

                // Follow $ref to ancestor types
                if (sub is OpenApiSchemaReference)
                {
                    foreach (string name in CollectBasePropertyNames(sub))
                    {
                        names.Add(name);
                    }
                }
            }
        }

        return names;
    }

    private static HashSet<string> CollectRequired(IOpenApiSchema schema)
    {
        var result = new HashSet<string>(StringComparer.Ordinal);

        if (schema.Required != null)
        {
            foreach (string r in schema.Required)
            {
                result.Add(r);
            }
        }

        // Collect required from allOf subschemas
        if (schema.AllOf is { Count: > 0 })
        {
            foreach (IOpenApiSchema sub in schema.AllOf)
            {
                if (sub.Required != null)
                {
                    foreach (string r in sub.Required)
                    {
                        result.Add(r);
                    }
                }
            }
        }

        return result;
    }

    private void EmitDocComment(string? description)
    {
        if (!_options.GenerateDocComments || string.IsNullOrWhiteSpace(description))
        {
            return;
        }

        string[] lines = description.Split(["\r\n", "\r", "\n"], StringSplitOptions.None);
        AppendLine("/// <summary>");
        foreach (string line in lines)
        {
            AppendLine($"/// {EscapeXmlDocComment(line)}");
        }
        AppendLine("/// </summary>");
    }

    private static string EscapeXmlDocComment(string text)
    {
        return text
            .Replace("&", "&amp;", StringComparison.Ordinal)
            .Replace("<", "&lt;", StringComparison.Ordinal)
            .Replace(">", "&gt;", StringComparison.Ordinal);
    }

    private void AppendLine(string? text = null)
    {
        if (text == null)
        {
            _sb.AppendLine();
        }
        else
        {
            _sb.Append(new string(' ', _indent * 4));
            _sb.AppendLine(text);
        }
    }

    private void Append(string text)
    {
        _sb.Append(new string(' ', _indent * 4));
        _sb.Append(text);
    }

    private void AppendLineRaw(string text)
    {
        _sb.AppendLine(text);
    }

    #endregion
}
